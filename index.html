<!DOCTYPE html>
<html>
<head>
  <title>Segmentation</title>
  <!-- <script src="./fabric.js"></script> -->
  <script src="./MagicWand.js"></script>
  <script src="./simplify.js"></script>
  <!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/fabric.js/1.4.0/fabric.min.js"></script> -->
  <script src="http://code.jquery.com/jquery-1.9.1.js"></script>
</head>
<body>
    <div style="overflow: auto">
        <div class="button" onclick="uploadClick()">Upload image and click on it</div>
        <!-- <div class="button" onclick="trace()">Create polygons by current selection</div>
        <div class="button" onclick="paint('FF0000', 0.35)">Paint the selection</div> -->
        <input id="file-upload" type="file" accept="image/*" onchange="imgChange(this)" />
        
    </div>
    <div style="overflow: auto">
        <input id="blurRadius" type="hidden" placeholder="blurRadius"/>
        <!-- <button onclick="updateRadios()">修改blurRadius</button> -->
        <input id="threshold" type="number" placeholder="threshold"/>
        <button onclick="updateShold()">修改threshold</button>
        <button onclick="reDraw()">确定</button>
    </div>
    <div>(hold left mouse button and move to change the color threshold)</div>
    <div class='wrapper'>
        <canvas class="canvas" id="resultCanvas" ></canvas>
        <img id="test-picture" class="picture" />
    </div>
</body>
<style>
.wrapper {
    top: 80px;
    overflow:auto;    
}
.content {
    position: relative;
}
.canvas:hover {
    cursor: default;
}
.button {
    padding: 4px;
    margin: 4px;
    border: 1px solid black;
    float: left;
}
.button:hover {
    background-color: blue;
    color: white;
    cursor: pointer
}
#blurRadius,#threshold {
    width: 50px;
}
#file-upload {
    display: none;
}
</style>
<script src="./fabric.js"></script>
<script>
let canvas = null
var mask = null;
var hasMask = null
window.onload = function() {
    colorThreshold = 15;
    blurRadius = 5;
    simplifyTolerant = 0;
    simplifyCount = 30;
    hatchLength = 4;
    hatchOffset = 0;

    imageInfo = null;
    cacheInd = null;
    
    downPoint = null;
    allowDraw = false;
    // currentThreshold = colorThreshold;
    
    // showThreshold();
    document.getElementById("blurRadius").value = blurRadius;
    document.getElementById("threshold").value = colorThreshold;
    // setInterval(function () { hatchTick(); }, 300);
};
function uploadClick() {
    document.getElementById("file-upload").click();
};
function updateRadios() {
    const val = $('#blurRadius').val()
    blurRadius = val;
};
function updateShold() {
    const val = $('#threshold').val()
    colorThreshold = val;
}
function imgChange (inp) {
    if (inp.files && inp.files[0]) {
        var reader = new FileReader();
        reader.onload = function (e) {
            var img = document.getElementById("test-picture");
            img.setAttribute('src', e.target.result);
            img.onload = function() {
                window.initCanvas(img);
            };
        }
        reader.readAsDataURL(inp.files[0]);
    }
};
function initCanvas(img) {
    // var cvs = document.getElementById("resultCanvas");
    // var canvas = cvs.getContext("2d")
    canvas = new fabric.Canvas('resultCanvas')
    canvas.setWidth(img.width);
    canvas.setHeight(img.height);
    imageInfo = {
        width: img.width,
        height: img.height,
        context: document.getElementById("resultCanvas").getContext("2d")
    };
    mask = null;
    const imgInstance = new fabric.Image(img);
    canvas.add(imgInstance);
    var tempCtx = document.createElement("canvas").getContext("2d");
    tempCtx.canvas.width = imageInfo.width;
    tempCtx.canvas.height = imageInfo.height;
    tempCtx.drawImage(img, 0, 0);
    // canvas.drawImage(img, 0, 0);
    imageInfo.data = tempCtx.getImageData(0, 0, imageInfo.width, imageInfo.height);
    initEvent()
};
function initEvent() {
    canvas.on("mouse:down", (options) => {
        onMouseDown(options.e)
    });
    canvas.on("mouse:up", (options) => {
        onMouseUp(options.e)
    });
}
function getMousePosition(e) {
    return { x: e.layerX, y: e.layerY };
};
function onMouseDown(e) {
    if (e.button == 0) {
        allowDraw = true;
        downPoint = getMousePosition(e);
        const objList = canvas.getObjects()
        const obj = objList[objList.length-1]
        // 最后一个是临时的就删掉
        if(obj.isTemp){
            canvas.remove(obj);
        }
        drawMask(downPoint.x, downPoint.y);
    }
    else allowDraw = false;
};
function onMouseMove(e) {
    if (allowDraw) {
        var p = getMousePosition(e);
        if (p.x != downPoint.x || p.y != downPoint.y) {
            var dx = p.x - downPoint.x,
                dy = p.y - downPoint.y,
                len = Math.sqrt(dx * dx + dy * dy),
                adx = Math.abs(dx),
                ady = Math.abs(dy),
                sign = adx > ady ? dx / adx : dy / ady;
            sign = sign < 0 ? sign / 5 : sign / 3;
            var thres = Math.min(Math.max(colorThreshold + Math.floor(sign * len), 1), 255);
            //var thres = Math.min(colorThreshold + Math.floor(len / 3), 255);
            // if (thres != currentThreshold) {
            //     currentThreshold = thres;
            //     drawMask(downPoint.x, downPoint.y);
            // }
        }
    }
};
function onMouseUp(e) {
    allowDraw = false;
    // currentThreshold = colorThreshold;
};
// function showThreshold() {
//     document.getElementById("threshold").value = currentThreshold;
// };
function drawMask(x, y) {
    if (!imageInfo) return;
    
    // showThreshold();
    
    var image = {
        // data: visited.data,
        data: imageInfo.data.data,
        width: imageInfo.width,
        height: imageInfo.height,
        bytes: 4
    };
    const temp = mask ? mask : image
    temp.bytes = 4
    mask = MagicWand.floodFill(image, x, y, colorThreshold, hasMask, true);
    mask = MagicWand.gaussBlurOnlyBorder(mask, blurRadius);
    // drawBorder();
    test1(mask)
};
function test1(mask) {
    let cs = MagicWand.traceContours(mask);
    cs = cs.filter(x => !x.inner);
    if (cs[0]) {
        let pts = cs[0].points;
        pts = simplify(pts, 1, true);
        path(pts)
    }
}
function path(contours) {
    // contours.sort(compare("x"))
    // contours.sort(compare("y"))
    let str = `M ${contours[0].x} ${contours[0].y}`
    for(let i=0;i<contours.length;i++){
        let item = contours[i]
        str+=`L ${item.x} ${item.y}`
    }
    str+=" z"
    var path = new fabric.Path(str);
    path.set({
        fill: 'rgba(1,1,1,0)',
        strokeDashArray: [1, 1],
        stroke: "black",
        strokeWidth: 1,
        hasBorders:false,
        isTemp: 1
    });
    canvas.add(path);
    canvas.setActiveObject(path)
}
function reDraw() {
    const objList = canvas.getObjects()
    const obj = objList[objList.length-1]
    obj.set({
        fill: 'red',
        isTemp: 0
    });
    canvas.requestRenderAll();
    canvas.setActiveObject(canvas.getObjects()[1])
    console.log('reDraw',mask.data)
    if(mask) {
        setVisited()
    }
}
// 设置访问过的点
function setVisited() {
    if(hasMask && hasMask.length>0) {
        const w = imageInfo.width
        const h = imageInfo.height
        const maskData = mask.data
        for(let i = 0; i < w * h; i++) {
            if(maskData[i] === 1) {
                hasMask[i] = 1
            }
        }
    } else {
        hasMask = mask && mask.data
    }
}
function hatchTick() {
    hatchOffset = (hatchOffset + 1) % (hatchLength * 2);
    drawBorder(true);
};
function drawBorder(noBorder) {
    if (!mask) return;
    
    var x,y,i,j,
        w = imageInfo.width,
        h = imageInfo.height,
        ctx = imageInfo.context,
        imgData = ctx.createImageData(w, h),
        res = imgData.data;
    
    if (!noBorder) cacheInd = MagicWand.getBorderIndices(mask);
    
    ctx.clearRect(0, 0, w, h);
    
    var len = cacheInd.length;
    for (j = 0; j < len; j++) {
        i = cacheInd[j];
        x = i % w; // calc x by index
        y = (i - x) / w; // calc y by index
        k = (y * w + x) * 4; 
        if ((x + y + hatchOffset) % (hatchLength * 2) < hatchLength) { // detect hatch color 
            res[k + 3] = 255; // black, change only alpha
        } else {
            res[k] = 255; // white
            res[k + 1] = 255;
            res[k + 2] = 255;
            res[k + 3] = 255;
        }
    }

    ctx.putImageData(imgData, 0, 0);
};
function trace() {
    var cs = MagicWand.traceContours(mask);
    cs = MagicWand.simplifyContours(cs, simplifyTolerant, simplifyCount);

    mask = null;

    // draw contours
    var ctx = imageInfo.context;
    ctx.clearRect(0, 0, imageInfo.width, imageInfo.height);
    //inner
    ctx.beginPath();
    for (var i = 0; i < cs.length; i++) {
        if (!cs[i].inner) continue;
        var ps = cs[i].points;
        ctx.moveTo(ps[0].x, ps[0].y);
        for (var j = 1; j < ps.length; j++) {
            ctx.lineTo(ps[j].x, ps[j].y);
        }
    }
    ctx.strokeStyle = "red";
    ctx.stroke();    
    //outer
    ctx.beginPath();
    for (var i = 0; i < cs.length; i++) {
        if (cs[i].inner) continue;
        var ps = cs[i].points;
        ctx.moveTo(ps[0].x, ps[0].y);
        for (var j = 1; j < ps.length; j++) {
            ctx.lineTo(ps[j].x, ps[j].y);
        }
    }
    ctx.strokeStyle = "blue";
    ctx.stroke();    
};
function paint(color, alpha) {
    if (!mask) return;
    
    var rgba = hexToRgb(color, alpha);
    
    var x,y,
    		data = mask.data,
    		bounds = mask.bounds,
        maskW = mask.width,
        w = imageInfo.width,
        h = imageInfo.height,
        ctx = imageInfo.context,
        imgData = ctx.createImageData(w, h),
        res = imgData.data;
    
    for (y = bounds.minY; y <= bounds.maxY; y++) {
      for (x = bounds.minX; x <= bounds.maxX; x++) {
      		if (data[y * maskW + x] == 0) continue;
          k = (y * w + x) * 4; 
          res[k] = rgba[0];
          res[k + 1] = rgba[1];
          res[k + 2] = rgba[2];
	        res[k + 3] = rgba[3];
      }
		}
    
    mask = null;
    
    ctx.putImageData(imgData, 0, 0);
};
function hexToRgb(hex, alpha) {
  var int = parseInt(hex, 16);
  var r = (int >> 16) & 255;
  var g = (int >> 8) & 255;
  var b = int & 255;

  return [r,g,b, Math.round(alpha * 255)];
}





</script>
</html>
